package attacks

/*
3 maneras de usar
[-] auth
[ ] prueba de directorios
[ ] form login
*/

import (
	"crypto/tls"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strings"
)

//RequestData Basic data for requests
type RequestData struct {
	User      string
	Pass      string
	UserAgent string
	Proxy     string
	Client    *http.Client
}

//NewRequestData Creates a requests data for http attacks
func NewRequestData() *RequestData {
	r := new(RequestData)
	r.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36"
	r.Client = &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
			},
		},
	}
	return r
}

//SetProxy set proxy the data
func (r *RequestData) SetProxy(urlPort string) {
	proxy, err := url.Parse(urlPort)
	if err != nil {
		log.Fatal("Error parsing url")
	}
	r.Client.Transport = &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: true,
		},
		Proxy: http.ProxyURL(proxy),
	}
}

//GetOrPost request for get or post method
func (r *RequestData) GetOrPost(urlsite string, post string) (string, int, *http.Response) {
	if post == "" {
		return r.Send("GET", urlsite, "")
	} else {
		return r.Send("POST", urlsite, post)
	}
}

//Send Send the data
func (r *RequestData) Send(method, urlsite, post string) (string, int, *http.Response) {

	var seppost []string
	seppost = strings.Split(post, "&")

	data := url.Values{}
	for _, v := range seppost {
		sep := strings.Split(v, "=")
		data.Set(sep[0], sep[1])
	}

	fmt.Println(green(data))
	req, err := http.NewRequest(method, urlsite, strings.NewReader(data.Encode()))

	if err != nil {
		fmt.Println("[!] Didn't get a response from the server")
		return "", 0, nil
	}

	if r.User != "" {
		req.SetBasicAuth(r.User, r.Pass)
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded; param=value")
	req.Header.Set("User-Agent", r.UserAgent)
	req.Header.Set("Accept-Encoding", "*")

	resp, err := r.Client.Do(req)
	if err != nil || resp == nil {
		return "", 0, nil
	}

	code := resp.StatusCode
	if resp.Body == nil {
		return "", code, resp
	}

	html, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", code, resp
	}
	resp.Body.Close()

	return string(html), code, resp
}

//SendAuth Send Auth request
func SendAuth(urlsite, post, username, password, proxy string) (string, int) { //, *http.Response) {
	r := NewRequestData()
	if proxy != "" {
		r.SetProxy(proxy)
	}
	r.User = username
	r.Pass = password
	html, code, _ := r.GetOrPost(urlsite, post)
	return html, code
}

//FileTry Send a request to verify a file if it exist
func FileTry(urlsite, word, fileWord, ext, post, proxy string) (string, int, string) {
	r := NewRequestData()
	if proxy != "" {
		r.SetProxy(proxy)
	}
	urlsite = strings.Replace(urlsite, word, fileWord+ext, 1)
	html, code, _ := r.GetOrPost(urlsite, post)
	return html, code, urlsite
}

//FormLogin Send a request of a form to log in
func FormLogin(urlsite, post, phrase, proxy string) (string, int, bool) {
	r := NewRequestData()
	if proxy != "" {
		r.SetProxy(proxy)
	}
	html, code, _ := r.GetOrPost(urlsite, post)
	html, code := r.postSended(urlsite, post)
	fmt.Println(html)
	html, code := postRequest(urlsite, post)
	return html, code, strings.Contains(html, phrase)
}

func postRequest(urlsite, post string) (string, int) {
	html := ""
	code := 200
	return html, code
}

func (r *RequestData) postSended(urlsite, post string) (string, int) {

	data := url.Values{}
	data.Set("username", "molly")
	data.Add("password", "sunshine")
	fmt.Println(data.Encode())

	resp, _ := r.Client.PostForm(urlsite, data)
	// client := &http.Client{}
	// req, _ := http.NewRequest(http.MethodPost, urlsite, strings.NewReader(data.Encode())) // URL-encoded payload
	// req.Header.Add("Authorization", "auth_token=\"XXXXXXX\"")
	// req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	// req.Header.Add("Content-Length", strconv.Itoa(len(data.Encode())))

	// resp, _ := client.Do(req)
	html, _ := ioutil.ReadAll(resp.Body)
	code := resp.StatusCode
	fmt.Println(resp.Body)
	return string(html), code
}
